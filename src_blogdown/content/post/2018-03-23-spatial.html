---
title: "Investigations Spatiales et Cartographiques"
author: ~
date: '2018-03-23'
slug: spatial
categories: ["R"]
tags: ["workshop", "package", "sp"]
header:
  caption: ''
  image: ''
---



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<div id="les-donnees-spatiales-et-r" class="section level2 smaller">
<h2>Les données spatiales et R</h2>
<p>Les données spatiales se présentes sous la forme de:</p>
<ul>
<li><p><code>vecteurs</code> (points, vecteurs, lignes, etc)</p></li>
<li><p><code>raster</code> (pixels).</p></li>
</ul>
<p>R permet de lire, d’écrire et de manipuler des données géoréférencées, puis d’en faire l’analyse statistique. Nous avons repérés deux packages de base :</p>
<ul>
<li><p><code>sp</code> - classe de base pour gérér des données spatiales, en particulier vectorisées, mais aussi grilles.</p></li>
<li><p><code>raster</code> - classes et outils pour manipuler des données sous forme raster.</p></li>
</ul>
<p><span class="math inline">\(+\)</span> des outils, divers et variés, en particulier:</p>
<ul>
<li><p><code>rgdal</code>: Interface R pour la library C/C++ de stat spatiales <code>gdal</code> (Geospatial Data Abstraction Library) pour lire et écrire des données spatialisées</p></li>
<li><p><code>rgeos</code>: Interface R de la library <code>geos</code> (Geometry Engine Open Source) avec opérations de type ensemblistes</p></li>
</ul>
<p>Bien d’autres packages spatiaux sur le CRAN!, voir - <a href="http://cran.r-project.org/web/views/Spatial.html">Spatial task view</a></p>
</div>
<div id="que-fait-on-aujourdhui" class="section level2">
<h2>Que fait-on aujourd’hui ?</h2>
<p>On étudie les packages <strong>sp</strong> puis <strong>gstat</strong>…puis <strong>spacetime</strong></p>
<p>Il est possible de bricoler avec l’emploi des commandes uniquement de base de R, telles que data.frame, image, etc….<strong>MAIS</strong> pourquoi utiliser un package?</p>
<p>Accepter de perdre un peu de liberté indisciplinée ?</p>
<ul>
<li>pour travailler et partager avec d’autres collègues,</li>
<li>pour récupérer le travail d’autres collègues.</li>
<li>bénéficier des fondations et des extensions de <strong>sp</strong></li>
</ul>

<p>Présentation inspirée des exemples de <a href="http://asdar-book.org">ce bouquin</a> et du travail réalisé avec le réseau <a href="http://informatique-mia.inra.fr/resste/atelier">RESSTE</a></p>
</div>
<div id="r-nest-pas-simplement-la-calculette-du-statisticien" class="section level2">
<h2>R n’est pas simplement la calculette du statisticien</h2>
<pre class="r"><code>cars$qspeed &lt;- cut(cars$speed, breaks=quantile(cars$speed), 
                   include.lowest=TRUE)
par(mfrow=c(1,2))
plot(dist ~ speed, data=cars)
plot(dist ~ qspeed, data=cars)</code></pre>
<p><img src="2018-03-23-spatial_files/figure-html/calculette-1.png" width="672" /></p>
<pre class="r"><code>par(mfrow=c(1,1))</code></pre>
</div>
<div id="le-package-sp-definit-des-classes-dobjet-explicitement-spatialises" class="section level2">
<h2>Le package sp définit des classes d’objet explicitement spatialisés</h2>
<pre class="r"><code>library(sp)
getClass(&quot;Spatial&quot;)
## Class &quot;Spatial&quot; [package &quot;sp&quot;]
## 
## Slots:
##                               
## Name:         bbox proj4string
## Class:      matrix         CRS
## 
## Known Subclasses: 
## Class &quot;SpatialPoints&quot;, directly
## Class &quot;SpatialMultiPoints&quot;, directly
## Class &quot;SpatialGrid&quot;, directly
## Class &quot;SpatialLines&quot;, directly
## Class &quot;SpatialPolygons&quot;, directly
## Class &quot;SpatialPointsDataFrame&quot;, by class &quot;SpatialPoints&quot;, distance 2
## Class &quot;SpatialPixels&quot;, by class &quot;SpatialPoints&quot;, distance 2
## Class &quot;SpatialMultiPointsDataFrame&quot;, by class &quot;SpatialMultiPoints&quot;, distance 2
## Class &quot;SpatialGridDataFrame&quot;, by class &quot;SpatialGrid&quot;, distance 2
## Class &quot;SpatialLinesDataFrame&quot;, by class &quot;SpatialLines&quot;, distance 2
## Class &quot;SpatialPixelsDataFrame&quot;, by class &quot;SpatialPoints&quot;, distance 3
## Class &quot;SpatialPolygonsDataFrame&quot;, by class &quot;SpatialPolygons&quot;, distance 2</code></pre>
</div>
<div id="le-package-sp-definit-des-classes-dobjet-explicitement-spatialises-1" class="section level2">
<h2>Le package sp définit des classes d’objet explicitement spatialisés</h2>
<ul>
<li>Points avec ou sans data : <em>SpatialPoints</em> et <em>SpatialPointsDataFrame</em></li>
<li>Pixels avec ou sans data : <em>SpatialPixels</em> et <em>SpatialPixelsDataFrame</em></li>
<li>Grilles avec ou sans data : <em>SpatialGrid</em> et <em>SpatialGridDataFrame</em></li>
<li>Lignes avec ou sans data : <em>SpatialGrid</em> et <em>SpatialGridDataFrame</em></li>
<li>Polygones : <em>SpatialPolygons</em> et <em>SpatialPolygonsDataFrame</em></li>
</ul>
</div>
</div>
<div id="spatial-et-spatialpoints" class="section level1">
<h1>Spatial et SpatialPoints</h1>
<div id="la-classe-de-base-spatial" class="section level2">
<h2>La classe de base: Spatial</h2>
<p>Elle ne possède que 2 <em>slots</em></p>
<ul>
<li>un <em>bounding box</em> en longitude/latitude</li>
<li>un objet de la classe <em>CRS</em> (coordinate reference system), par défaut mise à CRS(as.character(NA)) . Voir plus tard ce qu’est un CRS.</li>
</ul>
<pre class="r"><code>library(sp)
m &lt;- matrix(c(-2,15,10,40), ncol=2, dimnames=list(NULL, c(&quot;min&quot;, &quot;max&quot;)))
crs &lt;- CRS(projargs=as.character(NA))
crs
## CRS arguments: NA
S &lt;- Spatial(bbox=m, proj4string=crs)
S
## An object of class &quot;Spatial&quot;
## Slot &quot;bbox&quot;:
##      min max
## [1,]  -2  10
## [2,]  15  40
## 
## Slot &quot;proj4string&quot;:
## CRS arguments: NA</code></pre>
</div>
<div id="pour-la-suite-de-lexpose-on-sappuie-sur-le-jeux-de-donnees-meuse" class="section level2">
<h2>Pour la suite de l’exposé, on s’appuie sur le jeux de données MEUSE</h2>
<pre class="r"><code># check for example data
data(meuse) # mesures de métaux lourds dans la meuse
str(meuse) # 155 observations et 14 variables
## &#39;data.frame&#39;:    155 obs. of  14 variables:
##  $ x      : num  181072 181025 181165 181298 181307 ...
##  $ y      : num  333611 333558 333537 333484 333330 ...
##  $ cadmium: num  11.7 8.6 6.5 2.6 2.8 3 3.2 2.8 2.4 1.6 ...
##  $ copper : num  85 81 68 81 48 61 31 29 37 24 ...
##  $ lead   : num  299 277 199 116 117 137 132 150 133 80 ...
##  $ zinc   : num  1022 1141 640 257 269 ...
##  $ elev   : num  7.91 6.98 7.8 7.66 7.48 ...
##  $ dist   : num  0.00136 0.01222 0.10303 0.19009 0.27709 ...
##  $ om     : num  13.6 14 13 8 8.7 7.8 9.2 9.5 10.6 6.3 ...
##  $ ffreq  : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ soil   : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 2 2 2 2 1 1 2 ...
##  $ lime   : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 2 2 2 1 1 1 1 1 1 1 ...
##  $ landuse: Factor w/ 15 levels &quot;Aa&quot;,&quot;Ab&quot;,&quot;Ag&quot;,..: 4 4 4 11 4 11 4 2 2 15 ...
##  $ dist.m : num  50 30 150 270 380 470 240 120 240 420 ...</code></pre>
</div>
<div id="spatial-points" class="section level2">
<h2>Spatial points</h2>
<p>On utilise les 2 colonnes du data.frame meuse renseignant les coordonnées géographiques pour en faire un objet <em>SpatialPoints</em></p>
<pre class="r"><code># check for example data
coords &lt;- SpatialPoints(meuse[, c(&quot;x&quot;, &quot;y&quot;)]) 
summary(coords)
## Object of class SpatialPoints
## Coordinates:
##      min    max
## x 178605 181390
## y 329714 333611
## Is projected: NA 
## proj4string : [NA]
## Number of points: 155</code></pre>
</div>
<div id="exercice-a-vous-de-jouer" class="section level2">
<h2>Exercice à vous de jouer</h2>
<div id="merci-a-maxime-beauchamp-et-laure-malherbe-de-lineris" class="section level3">
<h3>Merci à Maxime Beauchamp et Laure Malherbe de l’Ineris</h3>

</div>
</div>
<div id="exercice-a-vous-de-jouer-1" class="section level2">
<h2>Exercice à vous de jouer</h2>

</div>
<div id="exercice-a-vous-de-jouer-2" class="section level2">
<h2>Exercice à vous de jouer</h2>

</div>
<div id="exercice-1" class="section level2">
<h2>Exercice 1</h2>
<p>Lire les stations de suivi de la pollution atmosphérique en PM10, PM25 , NO2 et O3 dans le fichier <strong>AirBase_v7_stations.csv</strong>.</p>
<p>Extraire leur coordonnées, jeter les doublons et sélectionner les stations de France métropolitaine. En faire un objet <em>SpatialPoints</em> et les représenter.</p>
<p>On pourra extraire un fond de carte de la France par les commandes R suivantes:</p>
<pre class="r"><code>library(cshapes)
## Loading required package: maptools
## Checking rgeos availability: TRUE
## Loading required package: plyr
cs &lt;- cshp()
row.names(cs)=paste(as.character(cs$CNTRY_NAME),1:244)
numfrance=grep(&#39;France&#39;,row.names(cs)) #=106
cowcodefrance=cs$COWCODE[106]
france &lt;- cs[cs$COWCODE==cowcodefrance,]</code></pre>
<!-- ## Spatial points data frame -->
<!-- Retour à Meuse. On ajoute aux coordonnées géographiques les données pour en faire un objet  *SpatialPointsDataFrame*. Ca se comporte comme un dataframe! -->
<!-- ```{r faireSpatialPointsDataFrame1, echo = TRUE, warning = FALSE, message = TRUE} -->
<!-- meuse_sp <- SpatialPointsDataFrame(coords, meuse) -->
<!-- names(meuse_sp) -->
<!-- is(meuse_sp) -->
<!-- is(meuse) -->
<!-- #str(meuse_sp) -->
<!-- ``` -->
<!-- On aurait pu faire plus direct: -->
<!-- ```{r faireSpatialPointsDataFrame2, echo = TRUE, warning = FALSE, message = TRUE} -->
<!-- meuse_sp2 <- meuse -->
<!-- coordinates(meuse_sp2) <- ~x+y  -->
<!-- # str(meuse_sp2) -->
<!-- is(meuse_sp2) -->
<!-- ``` -->
<!-- ## Exercice 2 ## -->
<!-- Lire les données de pollution atmosphérique du 15 juin 2014 en PM10, PM25 , NO2 et O3 pour les stations actives de France métropolitaine dans les fichiers **PM10_20140615.csv**, **PM25_20140615.csv**, **NO2_20140615.csv** et **03_20140615.csv** . Les données manquantes sont codées -999. -->
<!-- On pourra utiliser les packages *tidyR* et *data.table* pour avoir recours à la méthode *merge*. Créer un objet *SpatialPointsDataFrame* contenant les enregistrements géolocalisés de PM10, PM25 , NO2 et O3 pour les stations actives au 15 juin 2014 dont on conservera le type et l'aire.  -->
<!-- ## Recap: ASDAR page 35 -->
<!-- \begin{center} -->
<!--   \includegraphics[width=1\textwidth]{figSpatialPoints.png} -->
<!-- \end{center} -->
<!-- # SpatialGrids & SpatialPixels -->
<!-- ## Spatial grids & pixels -->
<!--   2 representations pour les data sur une grille régulière rectangualire, orientée N-S et E-W: *SpatialPixels* et  *SpatialGrid* -->
<!--   - SpatialPixels comme SpatialPoints, mais avec coordonnées equi-espacées -->
<!--   - SpatialPixelsDataFrame = SpatialPixels+data -->
<!--   - SpatialGridDataFrame = grille entiere et NA où manquantes -->
<!-- ```{r faireSpatialPixelsDataFrame1, echo = TRUE, warning = FALSE, message = TRUE} -->
<!--  data(meuse.grid) -->
<!--  coords <- SpatialPixels(SpatialPoints(meuse.grid[, c("x","y")])) -->
<!-- meuse_spx <- SpatialPixelsDataFrame(coords, meuse.grid) -->
<!-- names(meuse_spx) -->
<!-- slot(meuse_spx, "grid") -->
<!-- object.size(meuse_spx)  -->
<!-- dim(slot(meuse_spx, "data")) -->
<!-- ``` -->
<!-- ## Spatial grids -->
<!--    On peut convertir un *SpatialPixels* en un *SpatialGrid*, ce qui économise de la place de stockage: -->
<!-- ```{r faireSpatialPixelsDataFrame2, echo = TRUE, warning = FALSE, message = TRUE} -->
<!-- meuse_sg <- meuse_spx -->
<!-- fullgrid(meuse_sg) <- TRUE  -->
<!-- slot(meuse_sg, "grid") -->
<!-- class(slot(meuse_sg, "grid")) -->
<!-- object.size(meuse_sg) -->
<!-- dim(slot(meuse_sg, "data")) -->
<!-- par(mfrow=c(1,1)) -->
<!-- ``` -->
<!-- ## Spatial grids -->
<!--  Interpolons par "inverse distance weighting" un objet *SpatialPointsDataFrame*  -->
<!-- ```{r faireSpatialPixelsDataFrame3, echo=TRUE, fig.height=2.5, message=TRUE, warning=FALSE} -->
<!-- library(gstat) -->
<!-- meuse_sg$zincIDW <- idw(zinc~1,meuse_sp, meuse_sg)$var1.pred  -->
<!-- #interpolation par un poids inverse à la distance -->
<!--     bubble(meuse_sp, "zinc",col = c("white", "orange")) -->
<!-- ``` -->
<!-- ## Spatial grids -->
<!-- L'interpolation par "inverse distance weighting" d'un objet *SpatialPointsDataFrame* crée un objet *SpatialGridDataFrame*: -->
<!-- ```{r faireSpatialPixelsDataFrame4, echo = TRUE, warning = FALSE, message = TRUE} -->
<!--     image(meuse_sg,"zincIDW", col= terrain.colors(7)) -->
<!-- ``` -->
<!-- ## Exercice 3 ## -->
<!-- * Lire le champ de pollution atmosphérique du 15 juin 2014 en PM10, PM25 , NO2 et O3 prévues par le code numérique CHIMERE  sur une grille régulière recouvrant la France métropolitaine dans le fichier **chim.20140615.csv**. -->
<!-- Vérifier que l'écartement entre les points est régulier et le corriger si nécessaire. Faire une représentation graphique du champ de prévisions de PM25 du 15 juin 2014 sur laquelle on pourra tracer le fond de carte des contours de la France métropolitaine. -->
<!-- Créer un objet *SpatialPixelDataFrame* . Quelle est sa taille? -->
<!-- Le transformer en un objet *SpatialGridDataFrame*. A-t-on économisé de l'espace de stockage? -->
<!-- * Interpoler par "inverse distance weighting" (en supposant qu'un écart d'un degré de latitude correspond à celui d'un degré de longiture) les observations de PM25 (un objet *SpatialPointsDataFrame* ) sur la grille des previsions Chimère (un objet *SpatialGridDataFrame*). Représenter les erreurs de previsions. -->
<!-- ## Recap ASDAR page 52 -->
<!-- \begin{center} -->
<!--   \includegraphics[width=1\textwidth]{figSpatialGrids.png} -->
<!-- \end{center} -->
<!-- # SpatialLines & SpatialPolygones -->
<!-- ## Polygons -->
<!-- * Un objet *Line* = ensemble de coordonnées 2D sans ordre. Un *Polygon* = *Line* fermée. *Lines*= liste de *Line*. -->
<!-- * Un objet *SpatialLines* = ensemble de listes de coordonnées 2D avec ordre. Idem pour *SpatialPolygons* -->
<!-- * *SpatialLinesDataFrame* et  *SpatialPolygonsDataFrame* =+ data.frame dont les lignes associées aux coordonnées. -->
<!-- ## Polygons et leur famille -->
<!-- Les données meuse du package **sp** contiennent les coordonnées des bords de la rivière. On les transforme en un objet *SpatialPolygons* : -->
<!-- ```{r faireSpatialPolygonsDataFrame1, echo = TRUE, warning = FALSE, message = TRUE} -->
<!-- data(meuse.riv) -->
<!-- str(meuse.riv) -->
<!-- meuse.riv_poly <- SpatialPolygons(list(Polygons(list(Polygon(meuse.riv)), ID = "meuse"))) -->
<!-- summary(meuse.riv_poly ) -->
<!-- ``` -->
<!-- ## *SpatialPolygons* + *SpatialPoints* + *SpatialPixels* -->
<!-- Le tout ensemble: -->
<!-- ```{r faireSpatialPolygonsDataFrame2, echo=TRUE, message=TRUE, warning=FALSE} -->
<!-- layout(matrix(1:4, 1, 4, byrow = TRUE)) -->
<!-- par(mar = c(0,0,1,0)) -->
<!-- #plot(meuse_sp, cex = 0.6) -->
<!-- is(meuse_sp) -->
<!-- cc = coordinates(meuse_sp) -->
<!-- meuse.sl = SpatialLines(list(Lines(list(Line(cc)), "mess"))) -->
<!-- #plot(meuse.sl) -->
<!-- is(meuse.sl) -->
<!-- #plot(meuse.riv_poly, col = "grey") -->
<!-- is(meuse.riv_poly) -->
<!-- #image(meuse_spx, col = "grey") -->
<!-- is(meuse_spx) -->
<!-- ``` -->
<!-- ##  *SpatialPoints* + *SpatialPolygons* + *SpatialPixels* -->
<!-- Le tout ensemble: -->
<!-- ```{r faireSpatialPolygonsDataFrame3, echo=FALSE, fig.width=3, message=TRUE, warning=FALSE} -->
<!-- plot(meuse_sp, cex = 0.6) -->
<!-- title("points") -->
<!-- plot(meuse.sl) -->
<!-- title("lines") -->
<!-- plot(meuse.riv_poly, col = "grey") -->
<!-- title("polygons") -->
<!-- image(meuse_spx, col = "grey") -->
<!-- title("grid") -->
<!-- par(mfrow=c(1,1)) -->
<!-- ``` -->
<!-- ##  *SpatialPoints* + *SpatialPolygons* + *SpatialPixels* -->
<!-- Le tout ensemble: -->
<!-- ```{r faireSpatialPolygonsDataFrame4, echo=FALSE, fig.width=6,fig.height=5, message=TRUE, warning=FALSE} -->
<!-- par(mfrow=c(1,1)) -->
<!-- image(meuse_spx, col = "grey") -->
<!-- plot(meuse.riv_poly, col = "blue",add=T) -->
<!-- plot(meuse_sp, cex = 1.6,add=T) -->
<!-- box() -->
<!-- ``` -->
<!-- ## Spatial Lines et *ContourLines2SLDF* -->
<!-- ```{r faireContourLines2SLDF1, echo=TRUE, fig.width=3, message=TRUE, warning=FALSE} -->
<!-- data(volcano) -->
<!-- #?ContourLines2SLDF -->
<!-- volcano_sl <- ContourLines2SLDF(contourLines(volcano,nlevels=10))  -->
<!-- sapply(slot(volcano_sl, "lines"), function(x) length(slot(x, "Lines"))) -->
<!-- volcano_sl$level -->
<!-- col <- terrain.colors(nlevels(volcano_sl$level))  -->
<!-- # plot(volcano_sl, bg = "grey70", -->
<!-- # col = col[as.numeric(volcano_sl$level)], lwd = 3) -->
<!-- ``` -->
<!-- ## Spatial Lines et *ContourLines2SLDF* -->
<!-- ```{r faireContourLines2SLDF2, echo=FALSE, fig.width=6,fig.height=5, message=TRUE, warning=FALSE} -->
<!-- plot(volcano_sl, bg = "grey70",col = col[as.numeric(volcano_sl$level)], lwd = 3) -->
<!-- ``` -->
<!-- ## Exercice 4 ## -->
<!-- * Quelle est la nature de l'objet *france* obtenu à partir du package *Cshapes* dans l'exercice 1 ? -->
<!-- * Créer des lignes de niveaux pour les previsions Chimère de PM25. Les transformer en un objet de la famille *SpatialPolygonsDataFrame*. Représenter ces lignes de niveaux sur celles obtenues pour l'interpolation ("IDW" ou "krigeage") obtenue à partir des observations de PM25. -->
<!-- ## Recap ASDAR page 40 -->
<!-- \begin{center} -->
<!--   \includegraphics[width=1\textwidth]{figSpatialPolygons.png} -->
<!-- \end{center} -->
</div>
</div>

---
title: "Happy R - Investigations Spatiales et Cartographiques "
subtitle: "Suite et Poursuite de la présentation de Jessica du 17/11/17"
author: "Eric & Isabelle"
date: "23 mars 2018"
fontsize: 8pt
output: 
  beamer_presentation:
    fig_width: 6
    fig_height: 3.5
    fig_caption: false
    keep_tex: true
---

```{r setupPLUS, include=FALSE, warning = FALSE}
#rm(list=ls())
library(rgdal)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(collapse = TRUE, warning=FALSE, message=FALSE)
options(width=70)
library(cshapes)
cs<-cshp()
row.names(cs)=paste(as.character(cs$CNTRY_NAME),1:244)
numfrance=grep('France',row.names(cs)) #=106
cowcodefrance=cs$COWCODE[106]
france <- cs[cs$COWCODE==cowcodefrance,]

data("meuse")
data(meuse.grid)
meuse_sp<-meuse
coordinates(meuse_sp) <- ~x+y
coords <- SpatialPixels(SpatialPoints(meuse.grid[, c("x","y")]))
meuse_spx <- SpatialPixelsDataFrame(coords, meuse.grid)
meuse_sg <- meuse_spx
fullgrid(meuse_sg) <- TRUE
data(meuse.riv)
meuse.riv_poly <- SpatialPolygons(list(Polygons(list(Polygon(meuse.riv)), ID = "meuse")))



```

# CRS (Merci à Nicolas SABY, Unité InfoSol, Orléans, cf. sa présentation atelier RESSTE)

## Un mille à l'équateur vaut une minute {.smaller}

\begin{center}
  \includegraphics[height=0.45\textheight]{figSaby1_1.png} 
\end{center}
\begin{center}
  \includegraphics[height=0.4\textheight]{figSaby1_2.png}
\end{center}


## De multiples systèmes de projection {.smaller}

\begin{center}
  \includegraphics[width=0.9\textwidth]{figSaby2.png} 
\end{center}


## La France {.smaller}

\begin{center}
  \includegraphics[width=0.9\textwidth]{figSaby3.png} 
\end{center}

## En R , deux façons théoriques de définir le système de projection

* par le nom du code EPSG, par exemple WGS84 = 4326 (google) ou 2154 (Lambert-93)

* par l'écriture directe du code à considérer dans le slot proj4string

```{r codeEPSGLambert, echo = TRUE, warning = FALSE, message = TRUE}
CRSargs(CRS("+init=epsg:2154"))
```

De fait, les objets spatiaux sont souvent dotés d'un CRS initial

```{r codeEPSGfrance, echo = TRUE, warning = FALSE, message = TRUE}
CRSargs(france@proj4string)
```
Si on ne sait, on cherche dans gdal et/ou on va sur le net: [http://spatialreference.org](http://spatialreference.org)

```{r chercheLambert, echo = TRUE, warning = FALSE, message = TRUE}
EPSG <- make_EPSG()
EPSG_Lambert <- EPSG [grep("Lambert", EPSG$note), 1:2] 
head(EPSG_Lambert)
```

## En R , en pratique il faut **transformer** les coordonnées via le système de projection

* C'est le rôle de la fonction de reprojection **spTransform()**
```{r reprojection, echo = TRUE, warning = FALSE, message = TRUE}
bbox(france)
france_Lambert93 <- spTransform(france, CRS("+init=epsg:2154"))
bbox(france_Lambert93)
```

* Cette reprojection est importante pour les calculs de distances (Variogrammes!)

* Exercice: Paris a pour latitude : 48.866667 et pour longitude : 2.333333. Quelles sont ses coordonnées sur une carte Lambert93? Quelles sont ses coordonnées en degrés, minutes, secondes (cf. dd2dms). Celles de Bordeaux sont 48.866667 et 2.333333. Quelle est la distance entre ces deux villes (cf. spDistsN1 et gzAzimuth)

* Exercice: La grille des prévisions CHIMERE est donnée en coordonnées long/lat. Transformer l'objet spatial construit à l'exercice 3 en Lambert93 et visaliser les deux cartes obtenues pour voir l'effet de la projection conique.

# Visualisation

## Graphe interactif avec locator

```{r interaction, eval=FALSE, echo= TRUE}
plot(meuse_sp)
region <- locator(type="o")
#finir avec Esc

n <- length(region$x)
p <- Polygon(cbind(region$x,region$y)[c(1:n,1),], hole=FALSE)
ps <- Polygons(list(p), ID = "region")
sps <- SpatialPolygons(list(ps))
plot(meuse_sp[sps,], pch=16, cex=1, add=TRUE, col="red")
# Voir ?over
plot(meuse_sp[!is.na(over(meuse_sp,sps)),], pch=16, cex=1, add=TRUE, col="blue")
#
pointschoisis<-identify(coordinates(meuse_sp))
print(pointschoisis)

```


## Graph interactif avec locator {.smaller}

\begin{center}
  \includegraphics[width=0.9\textwidth]{figlocator.png} 
\end{center}

## Visualisation treillis avec spplot

```{r visuspplot1, echo=TRUE, fig.height=3, message=TRUE, warning=FALSE}
par(mfrow=c(1,1))
library(RColorBrewer)
bleus <- brewer.pal(7, "Blues")
lead.st <- as.vector(scale(meuse$lead)); zinc.st <- as.vector(scale(meuse$zinc))
copper.st <- as.vector(scale(meuse$copper)); cadmium.st <- as.vector(scale(meuse$cadmium))
meuse.st<-data.frame(x=meuse$x, y=meuse$y,lead.st,zinc.st,copper.st,cadmium.st)
coordinates(meuse.st) <- ~x+y
cuts=c(-1.2,0,1,2,3,5)
spplot(meuse.st, c("cadmium.st", "copper.st", "lead.st", "zinc.st"), 
             key.space="right", main = "Standardised metallic deposits", cex = .75,
             cuts = cuts, col.regions=bleus)
```

## Visualisation spplot Kriege vs IDW


```{r visuspplot2, echo=TRUE, fig.height=3, message=TRUE}
library(gstat)
zn <- krige(zinc~1,meuse_sp,meuse_sg)
meuse_sg$zincIDW <- zn$var1.pred

vgmMeuse <- variogram(zinc~1, meuse_sp, cutoff=1000)
vgmExpMeuse <- fit.variogram(vgmMeuse, vgm(150000, "Exp", 1000, 40000))
plot(vgmMeuse, vgmExpMeuse, main="Exponential", col='black')
znkrige<-krige(zinc~1, meuse_sp,meuse_sg, model=vgmExpMeuse)
meuse_sg$zincKRG <- znkrige$var1.pred
```


## Construction de sp.layout

```{r visuspplot3, echo=TRUE, fig.height=3, message=TRUE, warning=FALSE}
river <- list("sp.polygons", meuse.riv_poly, col='darkblue', fill=T)
north <- list("SpatialPolygonsRescale", layout.north.arrow(), offset = 
                c(178750,332500),
              scale = 400)
scale <- list("SpatialPolygonsRescale", layout.scale.bar(), offset = 
                c(180200, 329800), scale = 1000, fill=c("transparent","black"))
txt1 <- list("sp.text", c(180200, 329950), "0")
txt2 <- list("sp.text", c(181200, 329950), "1 km")
pts <- list("sp.points", meuse_sp, pch = 3, col = "black")
meuse.layout <- list(river, north, scale, txt1, txt2, pts)

```

## Visualisation sp.layout+spplot

```{r visuspplot4, echo=TRUE, fig.height=3, message=TRUE, warning=FALSE}
meuse.layout <- list(river, north, scale, txt1, txt2, pts)
spplot(meuse_sg, c("zincIDW", "zincKRG"), sp.layout = meuse.layout, cuts=5, col.regions=bleus)

```


## Pistes pour le futur

1. Explorer le **package `sf` **  qui associe les fonctionalités de `sp`, `rgdal`, et  `rgeos` en un seul package *spatial features* fondé sur le principe `tidyverse`.

2. Les packages **outils** `rgeos`,`rgdal`,`maps`,`maptools`... Qui voudrait faire un tour d'horizon? La connection avec les outils SIG?

3. Continuer de comprendre la modélisation **geostatistique** et son inférence. L'étude des dépendances dans le modèle multinormal (d'observation ou latent)  peut être approché sous l'angle de la:
- **matrice de variance** qui analyse les corrélations spatiales sous forme de variogrammes (packages: structuré sur `sp`: `gstat`, ou indépendants: `spatial`,`field`,`RandomFields`, `GeoR`, etc. )
- **matrice de précision** qui décrit les indépendances conditionnelles (voir par exemple le package structuré sur `sp`: `spdep`)  ou son utilisation pour les modèles géostatistiques complexes `INLA`)

4. **Extensions de la géostatistique ** qui intéresseront le réseau RESSTE
- **Le spatio-temporel**  (packages: structuré sur `sp`: `spacetime`) sp+xts+data.frame=spacetime
- **Approche Bayesiennes** (réplicats MCMC de structure de type cartes)




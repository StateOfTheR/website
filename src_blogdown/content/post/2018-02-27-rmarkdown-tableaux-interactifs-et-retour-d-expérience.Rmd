---
title: 'Rmarkdown: tableaux interactifs et retour d''expérience'
author: "Mahendra Mariadassou"
date: "2018-02-23"
slug: rmarkdown-tableaux-interactifs-et-retour-d-expérience
categories: ["workshop"]
tags: ["R Markdown", "communication", "DT", "datatable", "kable"]
header:
  caption: ''
  image: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = ".")
```

# Motivation

## About R Markdown {.build}

- **Markdown**: a simple formatting syntax for authoring HTML, PDF, and MS Word documents. 
- **R Markdown**: a simple way to embed **R** chuncks in your markdown (see <http://rmarkdown.rstudio.com> and Antoine's presentation for more details).
- **Knitting** (Ctrl+Shift+K): generates a document with both content and output of embedded R code chunks.

$\Rightarrow$ Very useful for **reproducible research** and to **explore data**

## Today's goal {.build}

- Demonstrate various data frame display methods
- Explore the potential of the **DT** (DataTables) package

**About DT**

- **DT** is an **R** interface to the JavaScript library **DataTables**
- Data frames can be displayed as tables on HTML pages and **DT** provides pagination, filtering, sorting, etc. 
- A bit awkward in presentations but very useful for _full-fledged_ HTML reports. 
- See <http://rstudio.github.io/DT/> for details

## Printing data frame: ugly default {.smaller}

```{r ugly-default}
iris
```

## Using kable: much better {.smaller}

```{r better-df}
knitr::kable(iris)
```

## Using datatable: even better {.smaller}

```{r pressure}
DT::datatable(iris)
```

# The Basics

## Getting started with DT 

We first new to install **DT**
```{r install-DT, eval = FALSE}
install.packages("DT")
## or for the dev version
devtools::install_github('rstudio/DT')
```

and then load it, to avoid typing `DT::`, as usual and add `dplyr` (because everybody loves `dplyr`)
```{r load-DT, message = FALSE}
library(DT)
library(dplyr)
```

## Main function (many options!!)

```{r datatable, eval = FALSE}
datatable(data, options = list(), 
          class = "display", 
          callback = JS("return table;"), 
          rownames, colnames, container, caption = NULL, 
          filter = c("none", "bottom", "top"), 
          escape = TRUE, 
          style = "default", width = NULL, height = NULL, 
          elementId = NULL, 
          fillContainer = getOption("DT.fillContainer", NULL), 
          autoHideNavigation = getOption("DT.autoHideNavigation", 
                                         NULL), 
          selection = c("multiple", "single", "none"), 
          extensions = list(),
          plugins = NULL)
```

We'll see `filter`, `options` and `extensions` and different styling options. 

## (Mandatory) Hello World {.smaller}

<div class="red2">
We already did it but still...
</div>

```{r hello-world}
datatable(iris)
```

## Your Turn (I)

Download the example dataset and print it nicely

```{r your-turn-1}
data_dir <- "2018-02-27-rmarkdown-tableaux-interactifs-et-retour-d-expérience_data"
example <- read.csv(file = paste(data_dir,"example_table.csv", sep="/"), dec = ",", stringsAsFactors = FALSE)
##  example <- read.csv(file = "http://genome.jouy.inra.fr/~mmariadasso/HappyR/example_table.csv", dec = ",", stringsAsFactors = FALSE)
```

## Class 

The **class** argument allows you to customize cell style. All options are on <https://datatables.net/manual/styling/classes>

Some important ones are:

- *stripe*: row-striping
- *hover*: row higlighting on mouse over
- *row-border* / *cell-border*: borders only at top and bottom of the table or around all cells
- *order-column*: highlight the column currently used for ordering
- *nowrap*: disable line wrapping (for long text)
- *compact*: increase density

The default style `class = "display"` corresponds to *stripe*, *hover*, *row-border* and *order-column*

## Class: example {.smaller}

```{r compact}
datatable(iris, class = "compact cell-border")
```

## Show/Hide Rownames {.smaller}

```{r show-rownames}
datatable(head(mtcars, 3))
```

```{r hide-rownames}
datatable(head(mtcars, 3), rownames = FALSE)
```

## Change Colnames

- Specify **all** names
```{r all-names, eval = FALSE}
## By default, forgoes the 'rownames' column
datatable(head(iris), 
          colnames = c('Here', 'Are', 'Some', 'New', 'Names'))
```

- Specify **some** names
```{r some-names, eval = FALSE}
## But rownames is still the first column
datatable(head(iris), 
          colnames = c('foo' = 'Sepal.Length', 'bar' = 'Sepal.Width'))
```

- Specify **some** names (bis)
```{r some-names-bis, eval = FALSE}
datatable(head(iris), 
          colnames = c('foo' = 4, 'bar' = 5))
```

## Change Colnames (Cont'd) {.smaller}

All names
```{r all-names-show, echo=FALSE}
datatable(head(iris, 2), options = list(dom = "t"), 
          colnames = c('Here', 'Are', 'Some', 'New', 'Names'))
```
<br>

Some Names
```{r some-names-show, echo=FALSE}
datatable(head(iris, 2), options = list(dom = "t"), 
          colnames = c('foo' = 'Sepal.Length', 'bar' = 'Sepal.Width'))
```
<br>

Some Other Names
```{r some-names-bis-show, echo=FALSE}
datatable(head(iris, 2), options = list(dom = "t"), 
          colnames = c('foo' = 4, 'bar' = 5))
```

## Custom Header 

```{r custom-header}
# a custom table container
sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, 'ID'),
      th(rowspan = 2, 'Species'),
      th(colspan = 2, 'Sepal'),
      th(colspan = 2, 'Petal')
    ),
    tr(
      # lapply(rep(c('Length', 'Width'), 2), th) # for Paul/Michel
      th("Length"),
      th("Width"),
      th("Length"),
      th("Width")
    )
  )
))
```

## Custom Header (Cont'd)

```{r custom-header-show}
print(sketch)
```

## Custom Header (Cont'd)

```{r custom-header-use}
## Note that sketch has a header for rownames
datatable(iris[1:3, c(5, 1:4)], container = sketch)
```

<br>
Automatic header generated by `tableHeader(iris)`

## Your Turn (II)

Create a nicer header for the example dataset. 

## Filter

Column filters are enabled by changing the default <font color="red">`filter="none"`</font> to <font color="red">`filter="top"`</font> or <font color="red">`filter="bottom"`</font>

```{r filters}
datatable(iris[c(1:2, 149:150), c(1:3, 5)], filter = "top", 
          options = list(dom = "t"))
```

# Options 

## Initialization options

DataTable has a large number of initialization options <http://datatables.net/reference/option> that can be set using **options** 

```{r initialize, size="small"}
datatable(head(iris, 32), options = list(
  pageLength = 4, lengthMenu = c(4, 8, 16, 32)
))
```

## Examples: Sorting

```{r sorting, size="small"}
datatable(head(mtcars[, 1:6], 30), options = list(
  order = list(list(2, 'asc'), list(4, 'desc'))
))
```

## Examples: Sorting (Cont'd) 

```{r sorting-names, size="small"}
datatable(head(mtcars[, 1:6], 30), rownames = FALSE, options = list(
  order = list(list(2, 'asc'), list(4, 'desc'))
))
```

## Did you notice?

- The order is <font color = "red">different</font>
- In javascript, columns are numbered from $0$ to $n-1$
- Here rownames act as the fist column

## Important option: DOM

DataTable adds a number of elements to or around the table. Their nature and order is determined by **dom**

- **l** : length changing input control 
- **f** : filtering input
- **t** : the table (you want this one)
- **i** : information summary 
- **p** : pagination control
- **r** : processing display elements
- **B** : Buttons (used with `Buttons` extension)

## DOM: examples

```{r dom-t, size = "small"}
datatable(head(iris, 2), options = list(dom = "t"))
```

<br>
```{r dom-ft, size = "small"}
datatable(head(iris, 2), options = list(dom = "ft"))
```

## DOM: Order Matters

```{r, ref.label="dom-ft"}
```

<br>
```{r dom-tf, size = "small"}
datatable(head(iris, 2), options = list(dom = "tf"))
```

## DOM: last examples

Elements of **DOM** can be <font color = "red">duplicated</font>
```{r dom-duplicated, size = "small"}
datatable(head(iris, 5), options = list(dom = "plitil"))
```

## Useful Trick: hide column(s)

Must specify column(s) by **position** (not name)

```{r hide-column, size = "small"}
datatable(iris %>% head(5), 
          options=list(columnDefs = list(list(visible=FALSE, targets=1:2)), 
                       dom = "t"))
```



## Your Turn (III)

Sort the example dataset by Site, Phylum and increasing baseline fold-change. 

# Functions

## Formattings functions

Not all tables are created equal

```{r random-table, warning=FALSE}
set.seed(seed = 20171019)
jouy <- data.frame(unit   = c("MaIAGE", "GABI", "Micalis"), 
                   budget = c(-1000000, 3000000, 5000000), 
                   DU     = c("F", "F", "M"),
                   ETP    = c(55, 120, 300), 
                   hum    = runif(3, 0, 1))
datatable(jouy, options = list(dom = "t"))
```

## `format`* functions

**DT** provides you with various formatting helper functions

- `formatCurrency` (with `currency`, `digits` and `before` arguments)
- `formatRound` (with `digits` argument)
- `formatPercentage` (with `digits` argument)

```{r format-random-table, size = "small"}
tab <- datatable(jouy, options = list(dom = "t")) %>% 
  formatCurrency("budget", "€", before = FALSE) %>% 
  formatPercentage(5, digits = 2); tab
```

## `formatStyle` and `style`* functions 

`formatStyle` allows you to apply a class to CSS styles to columns. CSS styles are named in camelCase style (_i.e._ `font-weight` becomes `fontWeight`)

```{r inra-halloween-style}
tab %>% formatStyle("unit", color = "orange", 
                    fontWeight = "bold", backgroundColor = "black")
```

## `style`* functions {.build}

`style`* allow you to apply **conditional** styling to the cells

- `styleInterval` (with `cuts` and `values` arguments)
- `styleColorBar` (with `data` and `color` arguments)
- `styleEqual` (with `levels` and `values` arguments)

For power users, the **formattable** package provides many formatting function that are compatible with **DT**

## Conditional formatting

```{r cond-format}
tab %>% 
  formatStyle('budget', color = styleInterval(0, c("darkred", "darkgreen")), 
              fontWeight = "bold") %>% 
  formatStyle('hum', background = styleColorBar(jouy$hum, "lightblue"))
```

## Cross-columns formatting

```{r cross-format}
tab %>% formatStyle('unit', valueColumns = "DU",
                    backgroundColor = styleEqual(c("M", "F"),
                                                 c("lightblue", "pink")))

```

## Format Whole Rows
```{r format-rows}
tab %>% formatStyle('DU', target = "row", 
                    backgroundColor = styleEqual(c("M", "F"),
                                                 c("lightblue", "pink")))
```

## Your Turn (IV)

Format the example dataset to highlight some OTUs: 

- use bold font for significant OTUs at time T2
- use red (`pink`) / blue (`lightblue`) background color 

## Your Turn (V)

Format the example dataset to highlight some OTUs: 

- use bold font for significant OTUs at time T2
- use red (`pink`) / blue (`lightblue`) background color **only for significant OTUs**
- *hint*: you may need to define a new column with the product of `sign(lfc)` and `padj`

## Your Turn (VI)

Add Column-levels filters to make table searchable

# Extensions

## DataTables extension 

Extension provide additional features to `datatable`. Some nice ones are 

- `Buttons`: add export buttons to your table
- `ColReorder`: click and drag columns to reorder columns
- `RowReorder`: click and drag columns to reorder rows
- `Responsive`: datable automatically adjust the number of columns to page width 

## Buttons {.smaller}

You need to have **B** in your `dom` option for it to work

```{r buttons}
datatable(jouy, extensions = 'Buttons', 
          options = list(dom = 'Bftip',
                         buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
)
```

## ColReorder

You need to add `colRorder = TRUE` to the options

```{r colreorder}
datatable(jouy, extensions = 'ColReorder', 
          options = list(colReorder = TRUE))
```

## RowReorder

You need to add `rowRorder = TRUE` to the options

```{r rowreorder}
datatable(jouy, extensions = 'RowReorder', 
          options = list(rowReorder = TRUE))
```

## Responsive 

No need to add anything to the options

```{r responsive}
datatable(mtcars, extensions = 'Responsive')
```

## Combining Extensions

You can combine all previous extensions using named lists. You need to add `= NULL` as none of them requires optional arguments. 

```{r combine-extensions}
tab <- datatable(jouy, 
                 extensions = list(
                   "Buttons" = NULL, 
                   "ColReorder" = NULL, 
                   "RowReorder" = NULL, 
                   "Responsive" = NULL
                 ), 
                 options = list(
                   dom = "Bftip", 
                   colReorder = TRUE, 
                   rowReorder = TRUE, 
                   buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
                 ))
```

## Combining Extensions (Cont'd)

```{r show-combined-extensions}
tab
```

## Final Formatting

```{r format-tab}
tab %>% formatCurrency("budget", currency = "€", before = FALSE) %>% 
  formatPercentage("hum", digits = 2) %>% 
  formatStyle("unit", color = "orange", backgroundColor = "black", fontWeight = "bold") %>% 
  formatStyle("hum", background = styleColorBar(jouy$hum, "lightblue")) %>% 
  formatStyle("budget", color = styleInterval(0, c("darkred", "darkgreen")), fontWeight = "bold") %>% 
  formatStyle("DU", backgroundColor = styleEqual(c("M", "F"), c("lightblue", "pink"))) 
```

## Your turn (VII) {.smaller}

Add extensions to dazzle your biologist colleagues with your technical prowess

```{r final-example, echo = FALSE}
## sketch
sketch = htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th(rowspan = 2, ''),
      th(rowspan = 2, 'site'),
      th(rowspan = 2, 'comparison'),
      th(rowspan = 2, 'OTU'),
      th(colspan = 3, '28 jours'),
      th(colspan = 3, '5 mois'),
      th(rowspan = 2, 'Kingdom'),
      th(rowspan = 2, 'Phylum')
      ),
    tr(
      lapply(rep(c("lfc", "adj. p-val.", "abund"), 2), th)
      )
  )
))
## table
extab <- datatable(example %>% 
                     mutate(T1.format = T1.padj * sign(T1.lfc), 
                            T2.format = T2.padj * sign(T2.lfc)), 
                   extensions = list(
                     "Buttons" = NULL, 
                     "ColReorder" = NULL, 
                     "RowReorder" = NULL, 
                     "Responsive" = NULL
                   ), 
                   options = list(
                     dom = "Bftip", 
                     colReorder = TRUE, 
                     rowReorder = TRUE, 
                     buttons = c('copy', 'csv', 'excel', 'pdf', 'print'), 
                     columnDefs = list(list(visible=FALSE, targets= ncol(example)+1:2))
                   ), 
                   container = sketch)
## Print and format
final.tab <- extab %>% 
    formatRound(columns = c("T1.lfc", "T2.lfc", "T1.padj", "T2.padj"), digits = 3) %>%
    formatRound(columns = c("T1.abundance", "T2.abundance"), digits = 5) %>%
    formatStyle(columns = c("T1.lfc", "T1.padj", "T1.abundance"), 
                valueColumns = "T1.format", 
                fontWeight = styleInterval(c(-0.05, 0.05), 
                                           c("plain", "bold", "plain")), 
                backgroundColor = styleInterval(c(-0.05, 0, 0.05), 
                                                c("plain", "pink", "lightgreen", "plain"))) %>%
  formatStyle(columns = c("T2.lfc", "T2.padj", "T2.abundance"), 
                valueColumns = "T2.format", 
                fontWeight = styleInterval(c(-0.05, 0.05), 
                                           c("plain", "bold", "plain")), 
                backgroundColor = styleInterval(c(-0.05, 0, 0.05), 
                                                c("plain", "pink", "lightgreen", "plain")))
final.tab
```



# A few ending words

## Custom formatting

`styleColorBar` is not so good for humidity level: 

> - it rescales all values in the $[0, 1]$ 
> - but we already have values in $[0, 1]$!!

```{r stylebar}
styleColorBarPercent <- function(data, color, angle = 90) {
    rg = range(data, na.rm = TRUE, finite = TRUE)
    stopifnot(rg[1] > 0, rg[2] < 1)
    JS(sprintf("isNaN(parseFloat(value)) || value <= 0 ? '' : 'linear-gradient(%sdeg, transparent ' + (1 - value) * 100 + '%%, %s ' + (1 - value) * 100 + '%%)'", angle, color))
}
```

## Final Formatting (Cont'd)

```{r custom-format-tab}
tab %>% formatCurrency("budget", currency = "€", before = FALSE) %>% 
  formatPercentage("hum", digits = 2) %>% 
  formatStyle("unit", color = "orange", backgroundColor = "black", fontWeight = "bold") %>% 
  formatStyle("hum", background = styleColorBarPercent(jouy$hum, "lightblue")) %>% 
  formatStyle("budget", color = styleInterval(0, c("darkred", "darkgreen")), fontWeight = "bold") %>% 
  formatStyle("DU", backgroundColor = styleEqual(c("M", "F"), c("lightblue", "pink"))) 
```

## A note about formattable

We could have achieved the same result (for the last part) with **formattable** 

```{r formattable}
library(formattable)
formattable(jouy, list(hum = color_bar("lightblue"))) %>% 
  as.datatable(extensions = "Buttons",
               options = list(dom = "Bpt",
                              buttons = c('csv', 'excel')
                 ))
```


# Feedback

## Feedback {.flexbox .vcenter}

<font color = "red">**Questions?**</font>